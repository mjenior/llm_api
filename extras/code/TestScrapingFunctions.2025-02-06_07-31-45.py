# Code generated by gpt-4o-mini

import unittest
from unittest.mock import patch, Mock
import pandas as pd
from your_module import scrape_product_data, extract_product_info

class TestScrapingFunctions(unittest.TestCase):
    """Unit test suite for the scraping functions."""

    @patch('your_module.requests.get')
    def test_scrape_product_data_success(self, mock_get):
        """Test successful data scraping from a product listing page."""
        # Mock HTML response
        mock_html = '''
        <div class="product">
            <h2>Product 1</h2>
            <span class="price">$10.00</span>
            <p class="description">Description of Product 1</p>
            <span class="rating">4.5</span>
        </div>
        <div class="product">
            <h2>Product 2</h2>
            <span class="price">$20.00</span>
            <p class="description">Description of Product 2</p>
            <span class="rating"></span> <!-- No rating -->
        </div>
        '''
        # Set up the mock to return a successful response with the mock HTML
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.content = mock_html.encode('utf-8')
        mock_get.return_value = mock_response
        
        # Call the function
        df = scrape_product_data("http://example.com/products")
        
        # Validate the DataFrame content
        expected_data = {
            'name': ['Product 1', 'Product 2'],
            'price': ['$10.00', '$20.00'],
            'description': ['Description of Product 1', 'Description of Product 2'],
            'rating': ['4.5', 'No Rating']
        }
        expected_df = pd.DataFrame(expected_data)
        
        pd.testing.assert_frame_equal(df, expected_df)

    @patch('your_module.requests.get')
    def test_scrape_product_data_invalid_url(self, mock_get):
        """Test handling of an invalid/404 URL."""
        # Set up the mock to return a 404 error
        mock_response = Mock()
        mock_response.status_code = 404
        mock_get.return_value = mock_response
        
        # Call the function
        df = scrape_product_data("http://example.com/invalid")
        
        # Validate the DataFrame is empty
        self.assertTrue(df.empty)

    def test_extract_product_info(self):
        """Test the extraction of product information from HTML."""
        from bs4 import BeautifulSoup

        # Mock HTML for testing extraction
        mock_html = '''
        <div class="product">
            <h2>Product 1</h2>
            <span class="price">$10.00</span>
            <p class="description">Description of Product 1</p>
            <span class="rating">4.5</span>
        </div>
        <div class="product">
            <h2>Product 2</h2>
            <span class="price">$20.00</span>
            <p class="description">Description of Product 2</p>
            <span class="rating"></span>
        </div>
        '''
        soup = BeautifulSoup(mock_html, 'html.parser')

        # Call the extraction function
        products = extract_product_info(soup)

        # Expected results after extraction
        expected_data = [
            {'name': 'Product 1', 'price': '$10.00', 'description': 'Description of Product 1', 'rating': '4.5'},
            {'name': 'Product 2', 'price': '$20.00', 'description': 'Description of Product 2', 'rating': 'No Rating'}
        ]

        self.assertEqual(products, expected_data)

    @patch('your_module.requests.get')
    def test_scrape_product_data_timeout(self, mock_get):
        """Test handling of a request timeout."""
        # Simulate a timeout
        mock_get.side_effect = requests.exceptions.Timeout
        
        df = scrape_product_data("http://example.com/products")
        
        # Validate the DataFrame is empty
        self.assertTrue(df.empty)

if __name__ == '__main__':
    unittest.main()