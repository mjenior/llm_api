# Code generated by gpt-4o-mini

import unittest
from unittest.mock import patch, Mock
import pandas as pd
from your_module import fetch_product_data, scrape_products  # Adjust the import based on your module name

class TestWebScraping(unittest.TestCase):
    def setUp(self):
        """Set up common variables for all tests."""
        self.valid_url = "https://example.com/product/page/1"
        self.missing_rating_html = """
        <html>
            <body>
                <h1 class='product-title'>Test Product</h1>
                <span class='price'>$24.99</span>
                <div class='product-description'>This is a test product.</div>
                <!-- No rating provided -->
            </body>
        </html>
        """
        self.full_data_html = """
        <html>
            <body>
                <h1 class='product-title'>Test Product</h1>
                <span class='price'>$24.99</span>
                <div class='product-description'>This is a test product.</div>
                <div class='rating'>4.5 out of 5</div>
            </body>
        </html>
        """
    
    @patch('your_module.requests.get')
    def test_fetch_product_data_success(self, mock_get):
        """Test fetching product data successfully."""
        mock_get.return_value = Mock(status_code=200, content=self.full_data_html.encode('utf-8'))
        result = fetch_product_data(self.valid_url)

        expected_result = {
            'product_name': 'Test Product',
            'price': '$24.99',
            'description': 'This is a test product.',
            'rating': '4.5 out of 5'
        }

        self.assertEqual(result, expected_result)

    @patch('your_module.requests.get')
    def test_fetch_product_data_missing_rating(self, mock_get):
        """Test fetching product data where rating is missing."""
        mock_get.return_value = Mock(status_code=200, content=self.missing_rating_html.encode('utf-8'))
        result = fetch_product_data(self.valid_url)

        expected_result = {
            'product_name': 'Test Product',
            'price': '$24.99',
            'description': 'This is a test product.',
            'rating': 'No rating'
        }

        self.assertEqual(result, expected_result)

    @patch('your_module.requests.get')
    def test_fetch_product_data_network_error(self, mock_get):
        """Test network error handling."""
        mock_get.side_effect = requests.ConnectionError("Network error occurred")
        result = fetch_product_data(self.valid_url)

        self.assertEqual(result, {})

    @patch('your_module.requests.get')
    def test_scrape_products_successful(self, mock_get):
        """Test scraping multiple products successfully."""
        mock_get.return_value = Mock(status_code=200, content=self.full_data_html.encode('utf-8'))
        urls = [self.valid_url, self.valid_url]  # Mocking multiple calls
        df = scrape_products(urls)

        self.assertEqual(len(df), 2)
        self.assertEqual(df['product_name'][0], 'Test Product')

    @patch('your_module.requests.get')
    def test_scrape_products_missing_data(self, mock_get):
        """Test scraping where some products have missing data."""
        mock_get.side_effect = [
            Mock(status_code=200, content=self.full_data_html.encode('utf-8')),
            Mock(status_code=200, content=self.missing_rating_html.encode('utf-8'))
        ]
        urls = [self.valid_url, self.valid_url]  # Two different responses
        df = scrape_products(urls)

        self.assertEqual(len(df), 2)
        self.assertEqual(df['rating'][0], '4.5 out of 5')
        self.assertEqual(df['rating'][1], 'No rating')

    def test_scrape_products_empty_list(self):
        """Test handling of an empty list of URLs."""
        df = scrape_products([])

        self.assertTrue(df.empty)
        self.assertEqual(df.columns.tolist(), ["product_name", "price", "description", "rating"])

if __name__ == '__main__':
    unittest.main()